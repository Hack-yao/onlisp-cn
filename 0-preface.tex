%!TEX encoding = UTF-8 Unicode
% $Id: 0-preface.tex 5 2009-08-07 08:40:43Z binghe $

\chapter*{前言}
\label{chap:preface}

本书适用于那些想更上一层楼的~Lisp 程序员。书中假设读者已经初步了解~Lisp，但不要求有丰富的
编程经验。最初几章里会重温很多基础知识。我希望这些章节也会让有经验的~Lisp 程序员感兴趣，
因为它们以崭新的视角展示了熟知的主题。

通常很难一语道清一门编程语言的精髓，但~John
Foderato\index{Foderaro, John K.}\note{v} 的话已经很贴切了：

\begin{quote}
  Lisp 是一门可编程的编程语言。
  (Lisp is a programmable programming language.)
\end{quote}

这难免以偏概全，但这种让~Lisp 随心而变的能力，在很大程度上正是~Lisp 专
家和新手的不同之处。在自上而下，把程序逐渐具体化，用编程语言实现设计的
同时，资深的~Lisp 程序员也实践着自底向上的方法，他们通过创建语言来描
述程序的行为。本书教授自底向上编写程序的方法，因为这是~Lisp 与
生俱来的强项。

\section*{自底向上的设计~(Bottom-up Design)}
\label{sec:bottom-up_design}
\index{bottom-up design 自底向上的设计}

随着软件复杂度的增长，自底向上设计的重要性也日益提高。今天的程序可能不得不面对极其复杂
甚至开放式的需求。在这种情况下，传统的自上而下方法有时会失效。一种新的编程风格应运而生，
它和当前大部分计算机科学课程的思路截然不同:
一个自底向上的程序由一系列的层写成，每一层都作为更高一层的编程语言。
X Window\index{X Window} 和~\TeX\index{TeX@\TeX} 就是这种程序设计风格的典范。

本书有两层主题: 首先，对以自底向上的方法编制的程序来说，Lisp 语言是不二之选，
反过来，编写~Lisp 程序的话，采用自底向上的编程风格也是理所当然的。因此《On Lisp》将吸引两类读者。
对于那些有兴趣编写可扩展程序的人，本书将告诉你如果有了合适的语言，你能做些什么。对于~Lisp
程序员来说，本书提供了第一手的实践指南，指引他们把~Lisp 的优势发挥到极致。

本书选用现在的这个书名是为了强调自底向上编程对于~Lisp 的重要性。你不再仅仅是用
~Lisp 编写程序，\emph{在~Lisp 之上~(On Lisp)}，你可以构造自己的语言，然后再用
这个语言来写程序。

尽管用任何语言都可以写出自底向上风格的程序，但~Lisp 对于这种编程风格来
说是最自然的载体。在~Lisp 里，自底向上的设计并不是那种仅为少见的大型程
序或者高难程序服务的专门技术。任何规模的程序都可以在一定程度上以这种方
式编写。Lisp 从一开始就被设计成可扩展的语言。这种语言本身基本上就是一
个~Lisp 函数的集合，这些函数和你自己定义的没有本质区别。更进一步，Lisp
函数可以表达成列表，而列表同时也是~Lisp 的数据结构。这就意味着你可以写
出能生成~Lisp 代码的~Lisp 函数。

一个好的~Lisp 程序员必须懂得如何利用上述这种可能性。通常的途径是定义
一种称为\emph{宏}的操作符。驾驭宏是从编写正确的~Lisp 程序走向编写漂亮
的程序过程中最重要的一步。入门级~Lisp 书籍给宏留下的篇幅仅限于一个宏的简
短的概述: 解释一下宏是什么，加上几个例子蜻蜓点水地提一下，说能用它实
现一些奇妙的东西。不过本书会给予这些奇妙的东西特别的重视。这里的
目标之一就是把所有关于宏的知识作一次总结，在以往，人们只能从使用宏的
经验和教训中来吸取这些知识。

一般来说，Lisp 的入门读物都不会强调~Lisp 和其他语言的区别，这情有可原。
它们必须想办法把知识传授给那些被教育成只会用~Pascal 术语来构思程序的
学生。如果非要细究这些区别的话，只会把问题复杂化: 例如~\texttt{defun}
虽然\emph{看起来}像一个过程定义，但实际上，它是一个编写程序的程序，这个程
序生成了一段代码，而这段代码新建了一个函数对象，然后用函数定义时给出的
第一个参数作为这个函数对象的索引。

本书的目的之一就是解释究竟是什么使~Lisp 不同于其他语言。刚落笔时，
我心里明白，同等条件下自己会更倾向于用~Lisp 而不
是~C、Pascal 或~Fortran 来写程序。我也知道这不只是个人好恶的问题。但当
意识到就要郑重其事地告诉大家~Lisp 语言在某些方面更优秀时，我发
现应该做好准备，说说到底为什么。

曾有人问~Louis Armstrong\index{Armstrong，Louis} 什么是爵士乐\index{jazz 爵士乐}，
他答道~``如果你问爵士乐是什么，那你永远不会知道。''
但他确实以一种方式回答了这个问题：他向世人\emph{展示}了什么是爵士乐。同样也只有一种方式
来解释~Lisp 的威力\index{programming languages 编程语言!expressive power of 的表达能力}，就是演示那些对于其他语言来说极其困难甚至不可能实现的技术。多数关于编
程的书籍，包括~Lisp 编程书籍，采用的都是那些你可以用任何其它语言编写的程序。
《On Lisp》 涉及的多是那些只能用~Lisp 写的程序。可扩展性，\bup，
交互式开发，源代码转换，嵌入式语言\pozhehao{}这些都是~Lisp 展示其高级特性的舞台。

当然从理论上讲，任意图灵等价的编程语言能做的事，其它任何语言都可以做
到。但这种能力和编程语言的能力却完全是两码事。理论上，任何你能用编程语言
做到的事，也可以用图灵机\index{Turing Machines 图灵机}来做，但实际上在图
灵机上编程得不偿失。

所以，当我说这本书是关于如何做那些其他语言力所不及的事情的时候，我并非指数学意义上的~
``不可能''，而是从编程语言的角度出发的。这就是说，如果你不得不用~C 来写本书中的一些程序，
你可能需要先用~C 写一个~Lisp 编译器。举个例子，在~C 语言里嵌入~Prolog\pozhehao{}你能想象
这需要多少工作量吗?
第~\ref{chap:prolog} 章将说明如何用~180 行~Lisp 做到这一点。

尽管我希望能比单单演示~Lisp 的强大之处做得更多。我也想解释\emph{为何}~Lisp 与众不同。
这是一个更微妙的问题，这个问题是那么难回答，它无法使用诸如~``符号计算'' 这样的术语来搪塞。
我将尽我所学，尽可能清楚明白地解释这些问题。

\section*{本书规划}
\label{sec:plan_of_the_book}

由于函数是~Lisp 程序的基础，所以本书开始的几章是有关函数的。
第~\ref{chap:functions} 章解释~Lisp 函数究竟是什么，以及它们带来了何种可能。
第~\ref{chap:functional_programming} 章讨论函数型编程的优点，这是~Lisp 程序最主要的
风格。
第~\ref{chap:utility_functions} 章展示如何用函数来扩展~Lisp。
第~\ref{chap:returning_functions} 章建议了一种新的抽象方式，即返回其他函数的函数。
最后，第~\ref{chap:functions_as_representation} 章显示了怎样使用函数来取代传统的数据
结构。

本书剩下的篇幅则更加关注宏。一部分原因是因为宏本身的内容就更多些，
一部分是因为至今尚无著作完整地介绍过宏的方方面面。
第~\ref{chap:macros}--\ref{chap:other_macro_pitfalls} 章构成了一套关于宏技术的完整教程。
学完这个教程后，你将了解一个有经验的~Lisp 程序员所知的关于宏的大多数内容: 它们如何工作；怎样定义，
测试，以及调试它们；
何时应该使用以及何时不应该使用宏；宏的主要类型；怎样写生成宏展开代码的程序；
宏风格一般如何区别于~Lisp 风格；
以及怎样甄别和改正每一种宏特有的问题。

在这套宏教程之后，第~\ref{chap:classic_macros}--\ref{chap:destructuring}
章展示了一些可以用宏来构造的强有力的抽象机制。
第~\ref{chap:classic_macros} 章展示如何写典型的宏\pozhehao{}那些创造上下文，
或者实现循环或条件判断的宏。
第~\ref{chap:generalized_variables} 章解释宏在操作普通变量中的角色。
第~\ref{chap:computation_at_compile-time}
章展示宏如何通过将计算转移到编译期来使程序运行得更快。第~\ref{chap:anaphoric_macros}
章介绍了指代~(anaphoric) 宏，它允许你在程序里使用代词。
第~\ref{chap:macro_returning_functions}
章展示了宏如何为第~\ref{chap:returning_functions} 
章里定义的函数生成器提供一个更便利的接口。第~\ref{chap:macro-defining_macros}
章展示了如何使用定义宏的宏来让~Lisp 为你写程序。
第~\ref{chap:read-macros} 章讨论读取宏~(read-macro)，
以及第~\ref{chap:destructuring} 章，解构宏。

第~\ref{chap:a_query_compiler} 章开始了本书的第四部分，这一部分的重点是嵌入式语言。
第~\ref{chap:a_query_compiler} 章通过展示同一个程序，一个回答数据库查询的程序，
先是用解释器，然后用真正的嵌入式语言，来介绍这一主题。
第~\ref{chap:continuations} 章展示了如何将续延~(continuation) 的概念引入~Common Lisp
程序，这是一种描述延续性计算的对象。续延是一个强有力的工具，
可以用来实现多进程和非确定性选择。至于如何把这些控制结构嵌入到~Lisp 中，
第~\ref{chap:multiple_processes} 和
~\ref{chap:nondeterminism} 章将对此进一步展开讨论。
非确定性听上去好像是一种具有非同寻常能力的抽象机制，它让你的程序似乎能未卜先知。
第~\ref{chap:parsing_with_atns} 和~\ref{chap:prolog} 章展示了两种嵌入式语言，
它们证明了非确定性绝非浪得虚名: 一个完整的~ATN 解析器，以及一个嵌入式~Prolog，总共才~200
行代码\note{viii}。

这些程序的长短本身并没有什么意义。如果你喜欢写像天书一样的程序，没人知道
你用~200 行代码能写出什么。
关键在于，这些程序并非靠编程技巧才变得短小\index{brevity 简洁}，而是由于它们
是以~Lisp 所固有的，自然的方式写成的。
第~\ref{chap:parsing_with_atns} 和~\ref{chap:prolog} 章的用意并不是教授如何用一页
代码实现~ATN 解析器或者用两页实现~Prolog，
而是想说明这些程序，当给出它们最自然的~Lisp 实现的时候是如此的简洁。后面这两个章节的嵌入式
语言用实例证明了我开始时的两个观点:
Lisp 对于以自底向上的编程风格来说是一种自然的语言，同时自底向上的编程风格也是编写~Lisp
程序理所当然的方式。

本书以关于面向对象编程的讨论做结，其中特别讨论了~\textsc{clos}，Common Lisp 对象系统。
把这一主题留到最后，
我们可以更加清楚地看到，面向对象的编程方式是一种扩展，这种扩展植根于一些早已存在于~Lisp
的思想之上。它是多种可以建立\emph{在~Lisp 上}的抽象之一。

自成一章的附注始于第~\pageref{chap:notes} 页。这些注释里包括参考文献，补充或者替换的
代码，
或者是有关~Lisp，但和当前主题没有直接联系的一些文字。注释是用页面留白上的小圆圈标注出来的，就像这样
\bubblenote。另外还有一个关于包~(package) 的附录，在第~\pageref{chap:packages} 页。

去纽约逛一圈或许对世界上的多数文化会有走马观花的了解，同样，在把~Lisp 作为一门可扩展编程语言来学习
也能接触到大部分的~Lisp 技术。这里描述的大多数技术通常都已为~Lisp 社区所熟知，
但很多内容至今也没有在任何地方有记载。而有些问题，例如宏的作用或变量捕捉的本质，
甚至对于许多很有经验的~Lisp 程序员来说也只是一知半解。

\section*{示例}
\label{sec:examples}

Lisp 是个语言家族。由于~Common Lisp 仍然是广泛使用的方言，本书的大部
分示例都是使用~Common Lisp 编写的。在~1984 年，Guy Steele\index{Steele, Guy Lewis Jr.} 
的~\emph{Common Lisp: the Language}%
\index{Common Lisp: the Language@\emph{Common Lisp: the Language}}
(\textsc{cltl}1\index{CLTL@\textsc{cltl}|see{\emph{Common Lisp: the Language}}}) 首
次定义了这门语言\index{Common Lisp!definition of 的定义}。1990 年，该书
第二版~(\textsc{cltl}2) \note{ix} 出版以后，这一定义被取而代之，
\textsc{cltl}2 可能会让位于将来的~\textsc{ansi} 标准\index{ANSI Common
  Lisp@\textsc{Ansi} Common Lisp}。

本书包含数百个示例，小到简单的表达式，大至可运行的~Prolog 实现。书中代码的编写，
尽量照顾到了各个细节，使得它们可以在任何版本的~Common Lisp 上运行。
有极少数例子需要用到~\textsc{cltl}1 规范之外的特性，这些示例将会在正文中加以明确的标识。
最后几个章节里包括了一些~Scheme 的示例代码，这些代码也会有清楚的标记。

所有代码可以通过匿名~\textsc{FTP} 从~\texttt{endor.harvard.edu} 下载，
在~\texttt{pub/onlisp} 目录里。问题和评论可以发到~\texttt{onlisp@das.harvard.edu}。

\section*{致谢}
\label{sec:acknowledgements}

写此书时，我要特别感谢~Robert Morris 的帮助。我经常去向他寻求建议，每次都会满载而归。
本书的一些示例代码就来自他，包
括~\pageref{fig:avoiding_capture_with_closure}
页上的一个~\texttt{for} 版本，
\pageref{fig:anaphoric_variants_of_common_lisp_operators} 页上
的~\verb|aand| 版本，\pageref{fig:matching_function} 页
的~\texttt{match}，\pageref{fig:correct_choose_in_scheme} 页的广度优
先~\texttt{true-choose}，以及第~\ref{sec:prolog:an_interpreter} 节
的~Prolog 解释器。事实上，整本书都反映~(有时基本是抄录) 了过去七年来我
跟~Robert 之间的对话。(谢谢你，rtm！)

我还要特别感谢~David Moon，他仔细阅读了大部分手稿并且给出许多非常有用的评论。
第~\ref{chap:generalized_variables}
章是按照他的建议完全重写了的，\pageref{example:capture} 页关于变量捕捉
的示例代码也是他提供的。

我很幸运地拥有~David Touretzky 和~Skoma Brittain 两位技术审稿人。有些章节就
是在他们的建议下追加或者重写的。
第~\pageref{func:true-choice} 页给出的另一个非确定性选择操作符就出自~David Toureztky 的一个建议。

还有一些人欣然阅读了部分或全部手稿，他们是~Tom Cheatham，Richard Draves
(他在~1985 年也帮助重写了~\texttt{alambda} 和~\texttt{propmacro})，
John Foderaro，David Hendler，George Luger，Robert Muller，Mark
Nitzberg\index{Nitzberg, Mark|see {joke, pratical}}\index{joke, pratical|see {Nitzberg, Mark}}，以及~Guy Steele。 

我感谢~Cheatham 教授以及整个哈佛，他们为我提供了撰写此书的条件。也感谢~Aiken
实验室的全体成员，包括~Tony Hartman，Janusz Juda，Harry Bochner，以及~Joanne
Klys。

Prentice Hall 的工作人员干得非常出色。我为与~Alan Apt 这位优秀的编辑和好伙伴一
起共事感到幸运。同时也感谢~Mona Pompili，Shirley Michaels，以及~Shirley
McGuire 的组织工作和他们的幽默。

剑桥~Bow and Arrow 出版社的无与伦比的~Gino Lee 制作了封面。封面上的那棵树暗示了第~\pageref{sec:functions_from_lists} 页上
的观点。

本书使用~\LaTeX{} 排版，这是一种由~Leslie Lamport 在~Donald Knuth 的~\TeX{}
基础上设计的语言，
另外使用了来自~L. A. Carr，Van Jacobson 和~Guy Steele 的宏。插图由~John
Vlissides 和~Scott Stanton 设计的~idraw 完成。
整本书用~L. Peter Deutsch 的~Ghostscript 生成之后，在~Tim Theisen
的~Ghostview 里预览。Chiron Inc. 公司的~Gary Bisbee 制作了能用来进行照相制版的拷贝。

我要感谢其他许多人，包括~Paul Becker，Phil Chapnick，Alice Hartley，
Glenn Holloway，Meichun Hsu，Krzysztof Lenk，Arman Maghbouleh，Howard
Mullings，Nancy Parmet，Robert Penny，Gary Sabot，Patrick Slaney，Steve
Strassman，Dave Watkins，Weickers\index{Weicker，Jacqueline J.} 一家，
还有~Bill Woods。

最后，我要感谢我的父母，谢谢他们为我树立的榜样还有对我的鼓励；还有~Jackie，要是我听得进他说的话，
或许能学到点什么。

\vspace{5ex}

我希望阅读此书是件乐事。在所有我知道的语言中，Lisp 是我的最爱，只因它是最优美
的。本书着眼于最~Lisp 化的~Lisp。写作这本书的过程充满了乐趣\index{fun 乐趣}，
愿你在阅读此书时能感同身受。

\vspace{1in}

\hfill\emph{Paul Graham}

\vfill

%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-master: "onlisp-cn"
%%% End:
